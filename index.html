<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elsa's Magic (Light Version)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            /* 背景は少しシンプルに */
            background: #050a14;
            height: 100vh;
            cursor: pointer;
        }
        canvas {
            display: block;
        }
        #instruction {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #add8e6;
            font-family: sans-serif;
            pointer-events: none;
            user-select: none;
            text-align: center;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div id="instruction">軽量版：クリックして氷の魔法を放つ</div>
    <canvas id="canvas"></canvas>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let w, h;
    let fireworks = [];
    let particles = [];

    function resize() {
        w = canvas.width = window.innerWidth;
        h = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    const iceColors = [
        '#ffffff', '#e0ffff', '#add8e6', '#87cefa', '#00bfff'
    ];

    function random(min, max) {
        return Math.random() * (max - min) + min;
    }

    class Firework {
        constructor(sx, sy, tx, ty) {
            this.x = sx;
            this.y = sy;
            this.sx = sx;
            this.sy = sy;
            this.tx = tx;
            this.ty = ty;
            this.distanceToTarget = Math.sqrt(Math.pow(tx - sx, 2) + Math.pow(ty - sy, 2));
            this.distanceTraveled = 0;
            this.coordinates = [];
            this.coordinateCount = 3; // 軌跡を短くして軽量化
            while (this.coordinateCount--) {
                this.coordinates.push([this.x, this.y]);
            }
            this.angle = Math.atan2(ty - sy, tx - sx);
            this.speed = 4; // 少し速度アップ
            this.acceleration = 1.02;
        }

        update(index) {
            this.coordinates.pop();
            this.coordinates.unshift([this.x, this.y]);

            this.speed *= this.acceleration;
            let vx = Math.cos(this.angle) * this.speed;
            let vy = Math.sin(this.angle) * this.speed;
            this.distanceTraveled = Math.sqrt(Math.pow(this.sx - this.x, 2) + Math.pow(this.sy - this.y, 2));

            if (this.distanceTraveled >= this.distanceToTarget) {
                createParticles(this.tx, this.ty);
                fireworks.splice(index, 1);
            } else {
                this.x += vx;
                this.y += vy;
            }
        }

        draw() {
            ctx.beginPath();
            ctx.moveTo(this.coordinates[this.coordinates.length - 1][0], this.coordinates[this.coordinates.length - 1][1]);
            ctx.lineTo(this.x, this.y);
            ctx.strokeStyle = '#87cefa'; // シンプルな水色
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // ぼかしなしのシンプルな核
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    class Particle {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            // 軌跡配列を削除（描画負荷を大幅軽減）
            
            this.angle = random(0, Math.PI * 2);
            this.speed = random(1, 10);
            this.friction = 0.95;
            this.gravity = 0.4;
            this.alpha = 1;
            this.decay = random(0.01, 0.02); // 消えるのを少し早く
            this.color = iceColors[Math.floor(random(0, iceColors.length))];
            
            this.rotation = random(0, Math.PI * 2);
            this.rotationSpeed = random(-0.2, 0.2);
            this.size = random(2, 5); // 粒子を少し大きくして見栄え確保
        }

        update(index) {
            this.speed *= this.friction;
            this.x += Math.cos(this.angle) * this.speed;
            this.y += Math.sin(this.angle) * this.speed + this.gravity;
            this.alpha -= this.decay;
            this.rotation += this.rotationSpeed;

            if (this.alpha <= this.decay) {
                particles.splice(index, 1);
            }
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            
            ctx.fillStyle = this.color;
            ctx.globalAlpha = this.alpha;
            
            // ぼかし(shadowBlur)は削除。
            // 代わりに描画モードをlighterにすることで重なりを光らせる（軽量）

            ctx.beginPath();
            ctx.moveTo(0, -this.size);
            ctx.lineTo(this.size, 0);
            ctx.lineTo(0, this.size);
            ctx.lineTo(-this.size, 0);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }
    }

    function createParticles(x, y) {
        let particleCount = 60; // 数を150から60に削減
        while (particleCount--) {
            particles.push(new Particle(x, y));
        }
    }

    function loop() {
        requestAnimationFrame(loop);
        
        // 画面クリア処理の軽量化
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = 'rgba(5, 10, 20, 0.3)'; // 残像を少し短く
        ctx.fillRect(0, 0, w, h);

        // 重ね合わせ発光モード（軽い）
        ctx.globalCompositeOperation = 'lighter';

        let i = fireworks.length;
        while(i--) {
            fireworks[i].draw();
            fireworks[i].update(i);
        }

        let j = particles.length;
        while(j--) {
            particles[j].draw();
            particles[j].update(j);
        }
    }

    canvas.addEventListener('click', (e) => {
        const instruction = document.getElementById('instruction');
        if (instruction) instruction.style.display = 'none';
        fireworks.push(new Firework(w / 2, h, e.clientX, e.clientY));
    });

    loop();
</script>
</body>
</html>
